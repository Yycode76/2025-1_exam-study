
✅ 2025-04-07 알고리즘 복잡도 정리 노트

📌 실행 시간(running time)이란?
- 실행 시간 = 알고리즘이 수행하는 step 수
- 시간복잡도는 컴퓨터 성능과 무관하게, 연산량 증가율로 측정함

📘 점근적 표기법 (Asymptotic Notation)
| 표기법 | 의미 | 해석 |
|--------|------|------|
| O(g(n)) | 상한 | f(n)은 g(n)보다 더 느려질 수는 없다 (최악의 경우) |
| Ω(g(n)) | 하한 | f(n)은 g(n)보다 더 빨라질 수는 없다 (최선의 경우) |
| Θ(g(n)) | 정확한 차수 | f(n)과 g(n)이 정확히 같은 속도로 증가 |

- O(n³)은 n³보다 느리지 않다
- Ω(n³)은 n³보다 빠르지 않다
- Θ(n³)은 정확히 n³과 같다

🔍 재귀 함수의 시간복잡도
- 재귀 호출 횟수 × 각 호출의 처리 시간
- 대표 예: 피보나치 → O(2ⁿ)

📌 피보나치 함수 예시
int fib(int n) {
    if (n == 1 || n == 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
- 이진트리처럼 재귀 호출이 퍼짐
- 호출 횟수는 최대 2ⁿ개 → O(2ⁿ)
- 중복 계산이 많음 → 메모이제이션 사용 시 O(n)으로 개선 가능

🔁 반복문의 시간복잡도 분석 예시
int[] multiply(int[] inputs, int multiplier) {
    int[] nums = new int[inputs.length];      // 실행 1회
    for (int i = 0; i < inputs.length; i++) { // 조건 검사 N+1회
        nums[i] = inputs[i] * multiplier;     // 실행 N회
    }
    return nums;                              // 실행 1회
}

🔸 분석:
| 코드 | 횟수 |
|------|------|
| 배열 생성 | 1 |
| for문 조건검사 + i++ | N+1 |
| 곱셈 및 대입 | N |
| return | 1 |

- 전체 수행량: T(N) = c1 + c2(N+1) + c3N + c4
- 최종 시간복잡도: O(N)

📈 시간복잡도 vs 실제 실행 시간
- 실제 시간은 컴퓨터 성능에 따라 달라짐
- 그래서 초 단위가 아니라, step 수 기반의 복잡도 표기가 필요함

대표 복잡도 증가 속도:
| 복잡도 | 증가 속도 |
|--------|-----------|
| O(1) | 항상 일정 |
| O(log n) | 아주 느리게 증가 |
| O(n) | 선형 증가 |
| O(n log n) | 꽤 빠르게 증가 |
| O(n²) | 폭발적 증가 |
| O(2ⁿ) | 지수적 폭발 (매우 비효율적)

🧠 입력 크기별 허용 복잡도 실전 기준
| 입력 크기 | 허용 복잡도 |
|-----------|--------------|
| ≤ 10 | O(n!), O(2ⁿ) 가능 |
| ≤ 500 | O(n²) 가능 |
| ≤ 10⁶ ~ 10⁷ | O(n log n) 이하만 가능 |

💡 한 줄 요약
- 실행 시간은 step 수로 본다.
- 복잡도는 증가율만 본다.
- 가장 큰 차수만 남긴다.
